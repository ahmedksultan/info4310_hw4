<html>
    <head>
        <title>INFO 4310 - HW4</title>

        <!-- Loading scripts -->
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <script src="https://d3js.org/d3-array.v2.min.js"></script>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

        <!-- Styling -->
        <style>

            body {
                background-color: #f0f0f0;
                justify-items: center;
            }

            .header {
                padding-top: 4em;
                padding-left: 4em;
                font-family: 'Roboto Condensed';
            }

            .page-title { 
                margin: 0;
                font-size: 48px;
            }

            .header p { 
                margin: 0;
                font-size: 16px;
            }

            text {
                font-family: 'Roboto Condensed';
            }

            .toggle-holder {
                padding-left:7em;
                padding-top: 10px;
            }

            #container {
                padding-left: 4em;
                display: flex;
            }

            .title-text {
                font-size: 30px;
            }

        </style>
    </head>

    <body>

        <div class="header">
            <!-- ALL : Maybe an explanation or better title/subtitle could be helpful -->
            <h1 class="page-title"> What Do Men Think It Means To Be A Man? </h1>
            <br>
            <p>by <b>Carly Hu</b> (ch862), <b>Myna Lim</b> (ml2326), <b>Ahmed Sultan</b> (aks264), and <b>Sydney Wan</b> (ssw73) for Prof. Rzeszotarski's INFO 4310 class</p>
            <p style="color: grey; ">&emsp;<i>(original data and reporting by <b>Ella Koeze</b> and <b>Anna Maria Barry-Jester</b> for <a href="https://fivethirtyeight.com/features/what-do-men-think-it-means-to-be-a-man/">FiveThirtyEight</a>)</i></p>
        </div>
        <div class="toggle-holder" height="500" width="200" >

            <svg id="toggle-menu" height="100" width="500"></svg>


        </div>

        <div id="container">
            <!-- ALL : This is where our visualizations will go !!!!!!!!1! -->
            <svg id="chart" height="500" width="700" style="border: 1px solid blue;"></svg>
            <svg id="breakdown" height="500" width="700" style="border: 1px solid blue;"></svg>

        </div>
        
        <script>
            const requestData = async function() {
                const surveyData = await d3.json("data/masc_survey_formatted.json");
                const svg = d3.select("#chart");
                let margin = { top: 50, bottom: 40, right: 35, left: 120 }
                const width = svg.attr("width");
                const height = svg.attr("height");
                const chartWidth = width - margin.left - margin.right;
                const chartHeight = height - margin.top - margin.bottom;

                let annotations = svg.append("g").attr("id","annotations");
                let questionSelected = 0;
                let questionBox = svg.append("g").attr("id","points")
                    .attr("transform",`translate(${margin.left},${margin.top})`);
                let nextQuestion = svg.append("image")
                    .join('image')
                    .attr("xlink:href", 'data/right.png')
                    .attr("x", 30)
                    .attr("y", -20)
                    .attr("class", "nextQ")
                    .attr("width", 30)
                    .attr("height", 30)
                    .attr("fill", "blue")
                    .attr("transform",`translate(0,20)`)
                    .on("click", updateQuestion);

                let prevQuestion =svg.append("image")
                    .join('image')
                    .attr("xlink:href", 'data/left.png')
                    .attr("x", 0)
                    .attr("y", -20)
                    .attr("class", "prevQ")
                    .attr("width", 30)
                    .attr("height", 30)
                    .attr("fill", "red")
                    .attr("transform",`translate(0,20)`)
                    .on("click", updateQuestion);
                
                if (questionSelected == 0) {
                    prevQuestion.attr("visibility","hidden");}
                
                let category_data = surveyData.filter(function(d) {
                                            return (d["category"] === 'lifestyle')
                                        })



                let chartArea = svg.append("g").attr("id","points")
                    .attr("transform",`translate(${margin.left},${margin.top})`);

                //Adding Icons for the toggle bar at the top
                const categories = ["Masculinity", "Lifestyle", "Work", "Relationships"];
                const images = ['society.png', 'mirror.png', 'briefcase.png', 'rose.png'];

                const svg_toggle = d3.select("#toggle-menu");

                svg_toggle.selectAll("image")
                           .data(images)
                           .join("image")
                           .attr("xlink:href", (d, i) => `data/${images[i]}`)
                           .attr("width", 60)
                           .attr("height", 60)
                           .attr("x", (d, i) => i*100+10)
                           .attr("y", 10)
                           .on('mouseover', function () {
                                d3.select(this).style("opacity", "0.6");
                           })
                           .on('click', mouseEntersState);

                svg_toggle.selectAll("text")
                              .data(categories)
                              .enter()
                              .append("text")
                              .text(function(d, i){return categories[i];})
                              .attr("x", (d, i) => i*100+35)
                              .attr("y", 90)
                              .style("text-anchor", "middle");

                const titlebar = svg.append("g").attr("transform", "translate("+margin.left+","+margin.top+")");
                //console.log(surveyData);

                
                updateChart(0);

                function updateChart(question_num) {
                    //clear labels
                    annotations.html("");
                    questionBox.html("");
                    //svg_breakdown.html("");

                    updateBreakdown(question_num);

                    //change question and change data based on question
                    questionBox.append("text")
                           .text(category_data[question_num]['question']);
                    const data = category_data[question_num] 
                    //reformat data for bar chart 
                    const data_formatted = Object.entries(data["adults"]).map(([key, value]) => ({
                                                            key: key,
                                                            value: value
                                                            }));

                    const answer = d3.keys(data['adults']); //getting the x-axis answers
                    const answerScale = d3.scaleBand().domain(answer).range([10, chartHeight])
                                                    .padding(0.05);
                                                    
                    const percentScale = d3.scaleLinear().domain([0, 100]).range([0, chartWidth]); 
                    let bottomAxis = d3.axisBottom(percentScale); 
                    let bottomGridlines = d3.axisBottom(percentScale)
                        .tickSize(-chartHeight)
                        .tickFormat(d3.format('.0%'));

                    annotations.append("g")
                        .attr("class", "x axis") 
                        .attr("transform", `translate(${margin.left},${chartHeight+margin.top})`)
                        //.tickFormat(d3.format('.0%'))
                        .call(bottomAxis); 

                    let leftAxis = d3.axisLeft(answerScale); 
                    let leftGridlines = d3.axisLeft(answerScale)
                        .tickSize(-chartWidth)
                        .tickFormat(""); 

                    annotations.append("g")
                        .attr("class", "y axis") 
                        .attr("transform", `translate(${margin.left - 10},${margin.top})`)
                        .call(leftAxis); 

                    annotations.append("g")
                        .attr("class", "y gridlines") 
                        .attr("transform", `translate(${margin.left - 10},${margin.top})`)  
                        .call(leftGridlines);                     

                    chartArea.selectAll('rect.bar').data(data_formatted)
                            .join(
                                enter => enter.append('rect')
                                    .attr('class', 'bar')
                                    .attr("fill", "#800f2f")
                                    .attr("stroke", "black")
                                    .attr("x", (d) => -10)
                                    .attr("y", (d) => answerScale(d['key']))
                                    .attr("width", (d) => percentScale(d['value']))
                                    .attr("height", answerScale.bandwidth())
                                    .on("mouseover", function(d) {
                                        chartArea.selectAll('rect.bar').filter(function() { 
                                            return this !== event.target;
                                        }).attr("opacity", 0.5);
                                        updateBreakdown(question_num, d.key); //calls the right graph so it can highlight that key
                                        })
                                        .on("mouseout", function() {
                                            chartArea.selectAll('rect.bar').attr("opacity", 1);
                                            updateBreakdown(question_num);
                                        }),
                                    update => update, // No-op for existing elements
                                    exit => exit.remove() // Remove bars that are no longer needed
                                );

                    }
                    

                //when right arrow box is clicked, 
                function updateQuestion(value) {
                    
                    prevQuestion.attr("visibility","visible");
                    nextQuestion.attr("visibility","visible");

                    if (d3.select(this).attr("class") == "nextQ") { questionSelected += 1; }
                    else { questionSelected -= 1;} 
                 
                    if (questionSelected === 0) {
                        prevQuestion.attr("visibility","hidden");}
                    if (questionSelected === category_data.length - 1) {
                        nextQuestion.attr("visibility","hidden");}
                        
                    questionBox.html("");
                    updateChart(questionSelected);


                }
                

   
                
                //function for when user clicks on an icon
                function mouseEntersState() {
                    titlebar.html("");
                    const selected = d3.select(this);
                    svg_toggle.selectAll("image").style("opacity", 1);
                    d3.select(this).style("opacity", "0.4");
                    
                    const image_name = selected._groups[0][0].__data__;

                    //Graphs dynamically change based on category
                    const title = categories[images.indexOf(image_name)].toLowerCase();

                    category_data = surveyData.filter(function(d) {
                                            return (d["category"] === title)
                                        })
                    
                    //resetting question toggle
                    questionSelected = 0;
                    prevQuestion.attr("visibility","hidden");
                    nextQuestion.attr("visibility","visible");

                    updateChart(questionSelected);

                }



                //Breakdown chart starts



                updateBreakdown(0);
                function updateBreakdown(question_num, color_key) { //color_key is for highlighting the key (e.g. very masculine)
                    const svg_breakdown = d3.select("#breakdown");
                    svg_breakdown.html("");
                    const breakdown_width = svg_breakdown.attr("width");
                    const breakdown_height = svg_breakdown.attr("height");
                    let break_margin = { top: 50, bottom: 5, right: 0, left: 90 }
                    const breakWidth = width - margin.left - margin.right;
                    const breakHeight = height - margin.top - margin.bottom;

                    let break_annotations = svg_breakdown.append("g").attr("id","annotations");
                    let breakArea = svg.append("g").attr("id","points")
                    .attr("transform",`translate(${margin.left},${margin.top})`);

                    const breakdowns = ["age_18-34", "age_35-64", "age_65+", "children_No", "children_Yes", "or_GayBisex",
                    "or_Straight", "race_NonWhite", "race_White"];
                    const data = category_data[question_num] 
                    //Gets only the demographic breakdown data
                    breakdown_data = Object.keys(data)
                                            .filter(key => breakdowns.includes(key))
                                            .reduce((obj, key) => {
                                                obj[key] = data[key];
                                                return obj;
                                            }, {});
                    //console.log(breakdown_data);

                    const better_data = [];

                    for (const [key, value] of Object.entries(breakdown_data)) {
                        let temp = {}
                        temp["category"] = key;
                        for (const [key2, value2] of Object.entries(value)) {
                            temp[key2] = value2;
                        }
                        better_data.push(temp);

                    }



                    let data_formatted = [];
                    breakdowns.forEach( (d, i) => {
                        const breakdownGroup = data[d];
                        data_formatted.push(Object.entries(breakdownGroup).map(([key, value]) => ({
                                                            breakdown: d,
                                                            category: key,
                                                            count: value,
                                                            })));
                    })
                    data_formatted = data_formatted.flat();

                    //console.log(data_formatted);
   
                    var subgroups = Object.keys(better_data[0]).slice(1)
                    //someone help me <3333333 
                    const series = d3.stack()
                                    .keys(subgroups)                 
                                (better_data);


                    // const answerScale = d3.scaleBand().domain(answer).range([10, chartHeight])
                    //                                 .padding(0.05);
                                                    
                    // const percentScale = d3.scaleLinear().domain([0, 100]).range([0, chartWidth]); 

                    var yScale = d3.scaleBand()
                                .domain(breakdowns)
                                .range([10, breakHeight])
                                .padding([0.2])
                    // svg_breakdown.append("g")
                    //             .attr("transform", "translate(0," + breakHeight + ")")
                    //             .call(d3.axisBottom(xScale).tickSizeOuter(0));

                    // Add Y axis
                    var xScale = d3.scaleLinear()
                        .domain([0, 100])
                        .range([ 0, breakWidth ]);
                        
                    svg_breakdown.append("g")
                        .call(d3.axisLeft(xScale));

                    var color = d3.scaleOrdinal() 
                                    .domain(subgroups)
                                    .range(['#f3dae1','#e7b5c2','#e1a3b3', '#db90a4', '#d57d95', '#ce6a85'])


                    //format af
                    let bottomAxis = d3.axisBottom(xScale); 
                    let bottomGridlines = d3.axisBottom(xScale)
                        .tickSize(-breakHeight)
                        .tickFormat(d3.format('.0%'));

                    break_annotations.append("g")
                        .attr("class", "x axis") 
                        .attr("transform", `translate(${break_margin.left},${breakHeight+break_margin.top})`)
                        //.tickFormat(d3.format('.0%'))
                        .call(bottomAxis); 

                    let leftAxis = d3.axisLeft(yScale); 
                    let leftGridlines = d3.axisLeft(yScale)
                        .tickSize(-breakWidth)
                        .tickFormat(""); 

                    break_annotations.append("g")
                        .attr("class", "y axis") 
                        .attr("transform", `translate(${break_margin.left - 10},${break_margin.top})`)
                        .call(leftAxis); 

                    break_annotations.append("g")
                        .attr("class", "y gridlines") 
                        .attr("transform", `translate(${break_margin.left - 10},${break_margin.top})`)  
                        .call(leftGridlines); 


                    svg_breakdown.append("g")
                        .selectAll("g")
                        // Enter in the stack data = loop key per key = group per group
                        .data(series)
                        .enter().append("g")
                        .attr("fill", function(d) { 
                            if (!color_key){
                                return color(d.key);
                            }
                            else {
                                return d.key === color_key ? color(d.key) : "lightgray";
                            }
                    
                            })
                        .selectAll("rect")
                        // enter a second time = loop subgroup per subgroup to add all rectangles
                        .data(function(d) { return d; })
                        .enter().append("rect")
                            .attr("y", function(d) { return yScale(d.data.category)+50;})
                            .attr("x", function(d) { return xScale(d[0]+15); })
                            .attr("width", function(d) { return (xScale(d[1]) - xScale(d[0])); })
                            .attr("height",yScale.bandwidth())

                    
                }


            }

            requestData();
            

            

            
        </script>

    </body>
</html>